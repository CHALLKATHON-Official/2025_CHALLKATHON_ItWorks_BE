const Diary = require("../js/diary");
const Group = require("../js/Group");
const mongoose = require('mongoose');

let currentStatus = "ÏûëÏÑ± Ï§ë";

// ‚úÖ ÏûëÏÑ± ÏÉÅÌÉú Î∞òÌôò
exports.getStatus = (req, res) => {
  res.json({ status: currentStatus });
};

// ‚úÖ ÎÇ†ÏßúÎ°ú ÏùºÍ∏∞ Ï°∞Ìöå (ÎÇ¥Í∞Ä ÏÜçÌïú Í∑∏Î£πÎßå)
exports.getDiaryByDate = async (req, res) => {
  try {
    const { date } = req.params;
    const userId = req.user?._id;

    if (!userId) {
      return res.status(401).json({ message: "Ïù∏Ï¶ùÎêú ÏÇ¨Ïö©ÏûêÎßå Ï†ëÍ∑º Í∞ÄÎä•Ìï©ÎãàÎã§." });
    }

    // ‚úÖ ÎÇ¥Í∞Ä ÏÜçÌïú Í∑∏Î£π Î™©Î°ù Î∂àÎü¨Ïò§Í∏∞ (ÎπÑÎ∞ÄÎ≤àÌò∏ Ìè¨Ìï®)
    const myGroups = await Group.find({ members: userId }).select("_id name password");

    const myGroupIds = myGroups.map((g) => g._id);
    const groupPasswordMap = new Map(
      myGroups.map((g) => [g._id.toString(), !!g.password]) // ‚Üê Î¨∏ÏûêÏó¥ ÌÇ§Î°ú Ï†ÄÏû•
    );

    // ‚úÖ Ìï¥Îãπ ÎÇ†ÏßúÏùò ÎÇ¥Í∞Ä ÏÜçÌïú Í∑∏Î£πÏùò ÏùºÍ∏∞Îì§ Ï°∞Ìöå
    const diaries = await Diary.find({
      date,
      group: { $in: myGroupIds },
    }).populate("group", "name");

    if (!diaries.length) {
      return res.status(404).json({ message: "Ìï¥Îãπ ÎÇ†ÏßúÏóê ÏùºÍ∏∞Í∞Ä ÏóÜÏäµÎãàÎã§." });
    }

    // ‚úÖ Í∑∏Î£πÎ≥ÑÎ°ú Î¨∂Í∏∞
    const groupMap = new Map();
    diaries.forEach((diary) => {
      const groupId = diary.group?._id?.toString() || "etc";
      const groupName = diary.group?.name || "Í∏∞ÌÉÄ";
      const hasPassword = groupPasswordMap.get(groupId) || false; // ‚Üê Î¨∏ÏûêÏó¥ ÌÇ§ ÏÇ¨Ïö©

      if (!groupMap.has(groupId)) {
        groupMap.set(groupId, {
          id: groupId,
          groupName,
          hasPassword, // ‚úÖ ÌîÑÎ°†Ìä∏Î°ú Ï†ÑÎã¨Îê®
          entries: [],
        });
      }

      groupMap.get(groupId).entries.push({
        id: diary._id,
        title: diary.title,
        imageUrl: diary.imageUrl || null,
        previewText: diary.title,
      });
    });

    const grouped = Array.from(groupMap.values());
    res.status(200).json(grouped);
  } catch (err) {
    console.error("‚ùå ÏùºÍ∏∞ Ï°∞Ìöå Ïã§Ìå®:", err);
    res.status(500).json({ message: "ÏÑúÎ≤Ñ Ïò§Î•ò" });
  }
};


// ‚úÖ ÏùΩÍ∏∞ Ï†ïÎ≥¥ Ï°∞Ìöå
exports.getReadInfo = async (req, res) => {
  try {
    const { id } = req.params;
    const diary = await Diary.findById(id);
    if (!diary) return res.status(404).json({ message: "ÏùºÍ∏∞Î•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§." });

    res.status(200).json({ readBy: diary.readBy || [] });
  } catch (err) {
    console.error("‚ùå ÏùΩÍ∏∞ Ï†ïÎ≥¥ Ï°∞Ìöå Ïã§Ìå®:", err);
    res.status(500).json({ message: "ÏÑúÎ≤Ñ Ïò§Î•ò" });
  }
};

// ‚úÖ ÏùΩÏùå Ï≤òÎ¶¨
exports.markAsRead = async (req, res) => {
  try {
    const { id } = req.params;
    const userEmail = req.user?.email;

    if (!userEmail) {
      return res.status(401).json({ message: "Ïù∏Ï¶ù Ïã§Ìå®" });
    }

    const diary = await Diary.findById(id);
    if (!diary) return res.status(404).json({ message: "ÏùºÍ∏∞Î•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§." });

    if (!diary.readBy.includes(userEmail)) {
      diary.readBy.push(userEmail);
      await diary.save();
    }

    res.status(200).json({ message: "ÏùΩÏùå Ï≤òÎ¶¨ ÏôÑÎ£å", readBy: diary.readBy });
  } catch (err) {
    console.error("‚ùå ÏùΩÏùå Ï≤òÎ¶¨ Ïã§Ìå®:", err);
    res.status(500).json({ message: "ÏÑúÎ≤Ñ Ïò§Î•ò" });
  }
};

// ‚úÖ ÏûêÎèô Ï†ÄÏû•
exports.autoSave = async (req, res) => {
  const { title, content } = req.body;
  const userId = req.user?._id;

  if (!userId) {
    return res.status(401).json({ message: "Ïù∏Ï¶ùÎêú ÏÇ¨Ïö©ÏûêÎßå Í∞ÄÎä•Ìï©ÎãàÎã§." });
  }

  try {
    const now = new Date();
    const today = now.toISOString().split("T")[0];

    const updated = await Diary.findOneAndUpdate(
      { user: userId, date: today, isTemp: true },
      {
        title,
        content,
        user: userId,
        date: today,
        isTemp: true,
        savedAt: now,
      },
      {
        new: true,
        upsert: true,
      }
    );

    console.log("üìù [Auto-Save] Ï†úÎ™©:", title, "| ÎÇ¥Ïö©:", content);
    currentStatus = "ÏûêÎèô Ï†ÄÏû•Îê®";

    res.status(200).json({ message: "ÏûêÎèô Ï†ÄÏû• ÏôÑÎ£å", diary: updated });
  } catch (err) {
    console.error("‚ùå ÏûêÎèô Ï†ÄÏû• Ïã§Ìå®:", err);
    res.status(500).json({ message: "ÏûêÎèô Ï†ÄÏû• Ïã§Ìå®", error: err.message });
  }
};

// ‚úÖ ÏûÑÏãú Ï†ÄÏû•
exports.saveTemp = async (req, res) => {
  const { title, content } = req.body;
  const userId = req.user._id;
  const today = new Date().toISOString().split("T")[0];

  try {
    const tempDiary = await Diary.findOneAndUpdate(
      { user: userId, date: today, isTemp: true },
      {
        title,
        content,
        user: userId,
        date: today,
        isTemp: true,
      },
      {
        new: true,
        upsert: true,
      }
    );

    console.log("üóÇ [Temp Save] Ï†ÄÏû• ÏôÑÎ£å:", tempDiary);
    res.status(200).json({ message: "ÏûÑÏãú Ï†ÄÏû• ÏôÑÎ£å", diary: tempDiary });
  } catch (err) {
    console.error("‚ùå ÏûÑÏãú Ï†ÄÏû• Ïã§Ìå®:", err);
    res.status(500).json({ message: "ÏûÑÏãú Ï†ÄÏû• Ïã§Ìå®", error: err.message });
  }
};

// ‚úÖ ÏùºÍ∏∞ ÏÉùÏÑ±
exports.createDiary = async (req, res) => {
  const { title, content, date, group, _id } = req.body;
  const userId = req.user?._id;

  console.log("üîç Ï†ÑÎã¨Îêú Îç∞Ïù¥ÌÑ∞:", { title, content, date, group });
  console.log("üìå Ïú†Ï†Ä ID:", userId);
  console.log("üì∑ ÏóÖÎ°úÎìú ÌååÏùº:", req.file);

  try {
    const imageUrl = req.file ? `/uploads/${req.file.filename}` : null;

    let diary;

    if (_id) {
      diary = await Diary.findByIdAndUpdate(
        _id,
        { title, content, date, group, user: userId, imageUrl, isTemp: false },
        { new: true, runValidators: true }
      );
    } else {
      diary = new Diary({
        title,
        content,
        date,
        group,
        user: userId,
        imageUrl,
        isTemp: false,
      });
      await diary.save();
    }

    console.log("üì• [Create Diary] Ï†ÄÏû• ÏôÑÎ£å:", diary);
    currentStatus = "ÏûëÏÑ± ÏôÑÎ£åÎê®";

    res.status(201).json({ message: "ÏùºÍ∏∞ ÏÉùÏÑ± ÏôÑÎ£å", diary });
  } catch (err) {
    console.error("‚ùå Ï†ÄÏû• Ïã§Ìå®:", err);
    res.status(500).json({ message: "ÏÑúÎ≤Ñ Ïò§Î•ò" });
  }
};

// ‚úÖ ÏõîÎ≥Ñ ÏùºÍ∏∞ Ïàò Ï°∞Ìöå
exports.getDiaryCountByDate = async (req, res) => {
  try {
    const userId = req.user?._id;
    const userEmail = req.user?.email;

    if (!userId || !userEmail) {
      return res.status(401).json({ message: "Ïù∏Ï¶ùÎêú ÏÇ¨Ïö©ÏûêÎßå Ï†ëÍ∑º Í∞ÄÎä•Ìï©ÎãàÎã§." });
    }

    let { year, month } = req.query;

    if (!year || !month) {
      return res.status(400).json({ message: "yearÏôÄ monthÎäî ÌïÑÏàòÏûÖÎãàÎã§." });
    }

    year = parseInt(year);
    month = parseInt(month);

    const paddedMonth = String(month).padStart(2, "0");
    const startDateStr = `${year}-${paddedMonth}-01`;
    const nextMonth =
      month === 12
        ? `${year + 1}-01-01`
        : `${year}-${String(month + 1).padStart(2, "0")}-01`;

    // ÏÇ¨Ïö©ÏûêÏùò Í∑∏Î£πÎßå ÌïÑÌÑ∞ÎßÅ
    const myGroups = await Group.find({ members: userId }).select("_id");
    const myGroupIds = myGroups.map((g) => g._id);

    const diaries = await Diary.find({
      group: { $in: myGroupIds },
      date: { $gte: startDateStr, $lt: nextMonth },
    }).select("date group readBy").lean();

    // ÎÇ†ÏßúÎ≥Ñ Ï¥àÍ∏∞ ÌÜµÍ≥Ñ
    const statsMap = {};
    const daysInMonth = new Date(year, month, 0).getDate();
    for (let day = 1; day <= daysInMonth; day++) {
      const dayStr = `${year}-${paddedMonth}-${String(day).padStart(2, "0")}`;
      statsMap[dayStr] = {
        totalCount: 0,
        unreadCount: 0,
        readCount: 0,
        groupsSet: new Set(),
      };
    }

    // ÏùºÍ∏∞Î≥Ñ ÌÜµÍ≥Ñ Ï≤òÎ¶¨
    diaries.forEach((diary) => {
      const dateStr = diary.date;
      const stat = statsMap[dateStr];
      if (!stat) return;

      stat.totalCount++;

      if (diary.readBy?.includes(userEmail)) {
        stat.readCount++;
      } else {
        stat.unreadCount++;
      }

      if (diary.group) {
        stat.groupsSet.add(diary.group.toString());
      }
    });

    // ÏµúÏ¢Ö Í≤∞Í≥º
    const result = {};
    Object.entries(statsMap).forEach(([date, stat]) => {
      result[date] = {
        totalCount: stat.totalCount,
        readCount: stat.readCount,
        unreadCount: stat.unreadCount,
        groupCount: stat.groupsSet.size,
      };
    });

    res.status(200).json(result);
  } catch (err) {
    console.error("‚ùå ÎÇ†ÏßúÎ≥Ñ ÏùºÍ∏∞ ÌÜµÍ≥Ñ Ï°∞Ìöå Ïã§Ìå®:", err);
    res.status(500).json({ message: "ÏÑúÎ≤Ñ Ïò§Î•ò" });
  }
};

// ‚úÖ Ï†ÑÏ≤¥ ÏùºÍ∏∞ Ïàò Ï°∞Ìöå
exports.getDiaryCount = async (req, res) => {
  try {
    const totalCount = await Diary.countDocuments({});
    res.json({ totalCount });
  } catch (err) {
    console.error(err);
    res.status(500).json({ message: "Ï¥ù ÏùºÍ∏∞ Í∞úÏàòÎ•º Í∞ÄÏ†∏Ïò¨ Ïàò ÏóÜÏäµÎãàÎã§." });
  }
};

// ‚úÖ ÏùºÍ∏∞ ÏÉÅÏÑ∏ Ï°∞Ìöå
exports.getDiaryById = async (req, res) => {
  try {
    const { id } = req.params;
    const diary = await Diary.findById(id).populate("group", "name");

    if (!diary) {
      return res.status(404).json({ message: "ÏùºÍ∏∞Î•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§." });
    }

    res.status(200).json(diary);
  } catch (err) {
    console.error("‚ùå ÏùºÍ∏∞ ÏÉÅÏÑ∏ Ï°∞Ìöå Ïã§Ìå®:", err);
    res.status(500).json({ message: "ÏÑúÎ≤Ñ Ïò§Î•ò" });
  }
};

exports.getDiariesByGroup = async (req, res) => {
  const { groupId } = req.params;
  const { date } = req.query;

  try {
    const query = { group: groupId };

    if (date) {
      const nextDay = new Date(date);
      nextDay.setDate(nextDay.getDate() + 1);
      const nextDayStr = nextDay.toISOString().slice(0, 10);

      query.date = { $gte: date, $lt: nextDayStr };
    }

    const diaries = await Diary.find(query)
      .populate("user", "name email")
      .sort({ date: -1 });

    res.json(diaries);
  } catch (err) {
    console.error("‚ùå Í∑∏Î£π ÏùºÍ∏∞ Ï°∞Ìöå Ïò§Î•ò:", err);
    res.status(500).json({ message: "ÏÑúÎ≤Ñ Ïò§Î•ò" });
  }
};

// ‚úÖ Í∑∏Î£πÎ≥Ñ ÎÇ†ÏßúÎ≥Ñ ÏùºÍ∏∞ Ïó¥Îûå/ÎØ∏Ïó¥Îûå ÌÜµÍ≥Ñ
exports.getGroupDiaryCountByDate = async (req, res) => {
  try {
    const userEmail = req.user?.email;
    const { groupId } = req.params;
    let { year, month } = req.query;

    if (!userEmail || !groupId || !year || !month) {
      return res.status(400).json({ message: "ÌïÑÏàò Ï†ïÎ≥¥Í∞Ä ÎàÑÎùΩÎêòÏóàÏäµÎãàÎã§." });
    }

    year = parseInt(year);
    month = parseInt(month);
    const paddedMonth = String(month).padStart(2, "0");

    const startDateStr = `${year}-${paddedMonth}-01`;
    const nextMonth =
      month === 12
        ? `${year + 1}-01-01`
        : `${year}-${String(month + 1).padStart(2, "0")}-01`;

    const diaries = await Diary.find({
      group: groupId,
      date: { $gte: startDateStr, $lt: nextMonth },
    }).select("date readBy");

    const statsMap = {};

    for (let i = 1; i <= new Date(year, month, 0).getDate(); i++) {
      const dateStr = `${year}-${paddedMonth}-${String(i).padStart(2, "0")}`;
      statsMap[dateStr] = {
        totalCount: 0,
        readCount: 0,
        unreadCount: 0,
      };
    }

    diaries.forEach((diary) => {
      const dateStr = diary.date;
      if (!statsMap[dateStr]) return;

      statsMap[dateStr].totalCount++;

      if (diary.readBy && diary.readBy.includes(userEmail)) {
        statsMap[dateStr].readCount++;
      } else {
        statsMap[dateStr].unreadCount++;
      }
    });

    res.status(200).json(statsMap);
  } catch (err) {
    console.error("‚ùå Í∑∏Î£πÎ≥Ñ ÏùºÍ∏∞ ÌÜµÍ≥Ñ Ï°∞Ìöå Ïã§Ìå®:", err);
    res.status(500).json({ message: "ÏÑúÎ≤Ñ Ïò§Î•ò" });
  }
};

exports.updateDiary = async (req, res) => {
  try {
    const { id } = req.params;
    const { title, content } = req.body;

    const updatedDiary = await Diary.findByIdAndUpdate(
      id,
      { title, content },
      { new: true }  // ÏàòÏ†ïÎêú Í≤∞Í≥º Î∞òÌôò
    );

    if (!updatedDiary) return res.status(404).json({ message: 'ÏùºÍ∏∞Î•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.' });

    res.json(updatedDiary);
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
};

exports.deleteDiary = async (req, res) => {
  try {
    const { id } = req.params;
    const deleted = await Diary.findByIdAndDelete(id);
    if (!deleted) return res.status(404).json({ message: 'ÏùºÍ∏∞Î•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.' });
    res.json({ message: 'ÏÇ≠Ï†ú ÏôÑÎ£å' });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
};